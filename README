(c) Copyright Paul Campbell paul@taniwha.com 2013

NOTE: lots here is still subject to change - we'll slowly chill then freeze the API over the next few
months

CC25xx RF library - this code is primarily intended for the raw 802.15 2533 interface but includes
some more generic OS features to help build useful systems.

Include files
=============

'apps' that want to work with this world should include 'interface.h' (which may pull in other include
files)- if you find you're including other include files you're probably not writing portable code.

OS model
========

The totally minimal OS simply consists of a timer queue - clients can queue events to occur some time in
the future - there are 32kHz/256 timer ticks per second (we provide a define HZ which is 32000/256) - this
timer runs with the rest of the chip in it's very deep sleep mode (we'll add an API for that soon).

A 'task' is a queueable element, it must be stored in __xdata, it contains a pointer to some code and
some task queue bookkeeping (these should be initialised to 0) - create a task with something like:

	void task_callback_routine(task_t  *);
	__xdata task task_block = {task_callback_routine,0,0,0};

Queue a task with:

	queue_task(&task_block, HZ/2);	// call task_callback_routine(&task_block) 1/2 a second from now

You can cancel a task with:

	cancel_task(&task_block);

A common thing to do is to call queue_task() with 0 which means call it asap (actually it goes after all
the other tasks about to be called). We have a shortcut for that queue_task_0(&task_block) which also
solves the problem of making calling it from interrupts safely (and sdcc's static storage of call arguments)

Task callback routines are called with the task block that was called out as a parameter - they've been
removed from the list and it's quit safe (and normal) to call queue_task() on them from within a callback
routine.

A task will not be interrupted by another task (even one queued with time 0 by an interrupt). There is no
preemption here, one tiny stack that has to be shared by everyone, local variables are expensive in this
architecture so use global variables - a state machine kicked by app calls and task callbacks is the
preferred way to go.

You should spend minimal time in tasks, as little as possible, get in do something, get out asap, don't
spin to delay time, queue another task.


RF access
=========

We have a bunch of routines for sending packets and controlling the RF interface:


	void rf_receive_on();	// turns the receiver on
	void rf_receive_off();	// turns the receiver off (saves a lot of power)
	

	void rf_set_transmit_power(char power); // sets output power 
		// valid values:	XMT_POWER_NEG_3DB	-3dB
		//			XMT_POWER_0DB		0dB
		//			XMT_POWER_4DB		+4dB
		//			XMT_POWER_MAXDB		MAX

	void rf_set_channel(u8 channel);	// channel 11-?

	void rf_set_key(u8 *key);	// set the 16-byte send/receive crypto key
	void rf_set_mac(u8 *key);	// set the 8-byte mac

	#define NO_CRYPTO 0xff
	extern u8 __data rtx_key;
	void rf_send(packet __xdata* pkt, u8 len, u8 crypto_key, u8 __xdata*mac);

rf_rend() sends a packet of length len, and applies crypto if requested using the supplied key number - use
'NO_CRYPTO' if you don't want the packet encrypted - key numbers must be less than or equal to 0x7f.
Key changes are done at theapp level whenever the RF layer needs to switch keys it will call your app
with APP_GET_KEY - in response you must call rf_set_key using the value in rtx_key to choose a key
(it's quite valid to just return a single key to all calls if that's what you need).

No guarantee is provided that a data gram will be received. The packet must be stored in __xdata.

The 'mac' argument can be NULL, if so a broadcast packet will be sent, otherwise a 64-bit MAC address is required.

The packet format we use is optional - you can use anything you like - however of you want to
use software update over the air you'll have to play nice and use it since the SUOTA protocol uses it.

	typedef struct packet {
        	u8      type;
        	u8      id[2];
        	u8      arch;
        	u8      version[3];
        	u8      data[1];
	} packet;

	//  type 	packet type - if you want to choose your own choose values over 0x40
	//		if you use crypto with private keys for all packets you wont collide
	//		as you'll never see anyone else's packets
	//  id[2]	node id - used to avoid broadcast storms in macless environments
	//  arch 	software object we support
	//  version[3]	version of software we support 
	//  data[N]	data payload - you only have ~100 bytes 802.11 packets are tiny

rf_send() will fill in id, arch, version for you

If SUOTA is enabled ('suota_enabled' is true) then the 'id', 'arch' and 'version fields will be filled in for you from your application header - otherwise all the bytes are yours to play with

The App interface is used to receive packets and will also poll for a crypto key and mac address during
system bring up. 

If you're using the playa macless protocol the first 3 bytes of the data packet are used for TTL and
to stop multiple retransmission of broadcast packets

	typedef struct broadcast_filter {
        	u8      hops;
        	u8      uniq[2];        // uniq filter
	} broadcast_filter;
	//  hops	used to stop packets from living forever in the net
	//  uniq[2]	unique packet filter (for routing) - if you set hops to 0 these
	//		bytes are available to you


Applications
============

The basic idea behind applications is that a CPU can have a small kernel and an application - the kernel
is fixed at manufacturing time while the application portion can be reliably updated over the radio
at any time - the kernel uses a small portion of the available flash memory (8k is the goal) - the rest
(24k on a 32k 2533) is split in two: half for the currently running app, the other half for an upgrading 
version.

At boot time the kernel runs a CRC check on the app image with the highest version number,
if it passes it becomes the running app, if the CRC fails the other app image is tested and if neither
passes a dummy app is installed (updates can still occur).

Apps have a standard App header:

	typedef struct code_hdr {
        	unsigned long    crc;         	
        	unsigned int     len;		// CRC starts here, len is length to the end
		unsigned char    arch;		// should be different for every board
		unsigned char    code_base;	// should be different for every type of code that runs on a board
        	unsigned char    version[2];	// version of that code bit 0 of byte 0 is the even/odd bit
        	unsigned char	 data[1];	// first byte of instruction executed in app
	} code_hdr;

The app is valid if a CRC32 for len bytes from 'arch' matches the CRC in the header - the entry point (code)
to the application starts at data[] - there's examples of how to code this in the sample app - this is
likely to change.

The build system automatically creates the code_hdr structure for you, populates its fields, including
the CRC and hooks the entry point up to my_app() - it also generates a hook that initialises initialised 
data areas for you.

An app consists of a single event routine which is called with an event selector, like everything get in
get out, as fast as you can - these calls are made from task callout routines:

	void *
	my_app(unsigned char op)	// app MUST be called "my_app"
	{
		case APP_INIT:
			//
			//	called once when an app originally starts, set up your hardware, any
			//	interrupts start tasks to perform periodic operations
			//
			return 0;	// return ignored
		case APP_GET_MAC:
			//
			//	return the address of the 8 byte mac address to use for
			//	this board - if you return NULL it will use the default 
			//	address programmed into the board at manufacture
			//	(can be overridden with rf_set_mac()
			//
			return (void *)&mac;
		case APP_GET_KEY:
			extern u8 __data rtx_key;
			//
			//	this is a request for you to set the 16 byte aes key number 
			//	selected by rtx_key by calling rf_set_key();
			//
			rf_set_key(&aes_keys[rtx_key][0]);
			return 0;
		case APP_RCV_PACKET:
			{
				// these are defined in interface.h, locations may change
				extern u8 __data rx_len;
				extern packet __xdata  * __data rx_packet;
				extern u8 __xdata  * __data rx_mac;
				extern __bit rx_crypto;
				extern __bit rx_broadcast;
				extern u8 rtx_key;
			
				//
				// rx_len bytes are stored pointed to by rx_packet;
				//
				// if rx_crypto is set the packet was encrypted 
				//	(and passed, bad crypto'd packets are discarded
				//	if it was encrypted rtx_key contains the key used
				//	to decrypt it)
				//
				//  if rx_broadcast is true the packet was sent as a broadcast
				//
				//  rx_mac is the mac address of the packet sender
				//
				//  when called the receiver is still running but can only buffer 
				//	a packet or two (depends on length) so be quick
				//
			}
			return 0;	// ignored
		case APP_WAKE:	
			// power wake (not yet implemented)
			return 0;	// ignored

		case APP_KEY:		// only on playa boards - capacitive key presses/releases
			{
				// these are defined in interface.h, locations may change
				extern u8 __pdata key;
				extern __bit key_down;
				#define	KEY_X		0
				#define	KEY_O		1
				#define	KEY_LEFT	2
				#define	KEY_RIGHT	3
				//
				//	key code for pressed key is in key, whether it was pressed
				//		or released is in key_down
				//
			}
			return 0;	// ignored

		default:
			return 0;	// for future comparability return 0 for undefined selectors
		}
	}

Software Update
===============

Software updates will be controllable - you can turn them off - and allow them to occur without crypto -
normally we will only accept update packets that match our cryto key, our current 'arch' and have a version
number bigger than our current app's version.

There will also be a mechanism to pass state from one set of firmware and another and to switch without
rebooting.

The 8051 has no long relative jumps/calls so even versioned app images are loaded into the low half
of the app memory space and odd versioned ones into the high space - software upgrade is a scary time, we
don't want to brick a board - upgrading from an even version to an even version or odd to odd, requires
an extra flash copy that can destroy both images if the power goes out half way through (the resultant
CRC failure should allow it to recover and reload cleanly) - this means we (eventually will) have a build
mechanism to compile an app to the appropriate address to match its version number (and a tool to fill the
CRC).

To update all the devices on a net you need to upgrade one, it will

Build System
============

The build system can be found in the top level Makefile in the CC-Kernel repository - we use SDCC for builds
(gcc doesn't support our platform) and in particular we support just one SDCC version (this doesn't mean
others wont work, just that they haven't been tested) - the version is available ????here????

SDCC uses dicfferent naming conventions for files:

	- .rel object files (equivalent to .o files)
	- .ihx binary code files, loadable intel hex (equivalend to executable binaries)
	- .lk linker code files
	- .lst source listing files
	- .rst source listing files with real binary addresses - post linking
	- .map link map output files

we also add:
	- .suota - code files suitable for SUOTA

There are two types of build:

- unified builds - all code (kernel and application) built into one image suitable for programming 
- SUOTA (software update over the air) - in this case we build a base kernel.ihx file that is 
	burned once into each device on manufacture - then we build even and odd SUTOA images 
	that can be downloaded over RF

We recommend you use unified builds until you are ready to freeze your kernel - then use SUOTA builds 

The basic process for building a kernel involves:

	- compile .rel files from .c
	- link .rel files to make .map and .ihx files

Build SUOTA loadable code (look at the instructions in the Makefile for a checklist):

	- build a kernel
	- make a linker control file kernel.lk by postprocessing the kernel
		map file using the map.pl file - this exports
		kernel symbols to apps so that they can call into the kernel and
		
	- compile app .rel files from .c
	- link .rel files plus linker control file kernel.lk to make a .ihx file
	- postprocess the .ihx file to make a .suota file using fixcrc which fills in the
		code_header structure and creates a binary file suitable for 
		the serial loader code to broadcast for SUOTA

Access to the Internet
======================

A network of devices is a bit useless without being able to get data in and out to the wider internet. 
While we don't support IP (or any routing, that's up to you) we do have a version of our software that
can be loaded into a dev board (serial.ihx) and which allows users to talk to it over a serial connection.
The interface librarry can be found in serial/packet_interface.cpp and serial/packet_interface.h - there
are C++ and plain C bindings available. The interface also supports a scriptable interface.

You can build packet_loader which uses this library and will run on a host system and provide a SUOTA
server serving multiple different types of boards, or you can build your own server that can do SUOTA as
well as providing your own gateway to anything you like. 

The packet_loader program takes one argument - the serial port that should be opened - it defaults to
/dev/USB0. If you give it the '-i script' flag it will open the script file and execute commands from it (for
example it could set up crypto keys and SUOTA files) then sit there forever responding to incoming packets.
If you don't give the -i flag it will open an interactive session and allow you to send and receive commands.

Crypto keys are 16 bytes - mac addressess are 8 bytes (not 6).

The access library allows you to create multiple independant gateways (using different serial ports) the
following methods are supported:

	opened_ok()		- true if the serial port opened
	on()			- turns the receiver on
	off()			- turns it off
	ping()			- just sends a packet to see if the board is alive
	reset()			- resets the developmenbt board
	set_auto_dump(FILE*)	- dumps packet contents to the named output file
	set_promiscuous(on/off)	- ignores mac addresses dumps all traffic seen
	set_raw(on/off)		- ignores crypto and dumps raw packet data
	set_channel(chan)	- sets the rf channel some value in the range 11-26
	set_mac(unsigned char *)- sets the mac addrtes (8 bytes)
	set_key(k, unsigned char *) - sets key number k (0-7) to the 16 bytes passed in
	send(mac, data, len)	- sends len bytes from data to mac (or broadcast if mac is NULL)
	send_crypto(k, mac, data, len)- same as send but encrypted with key k (0-7, must have been loaded already)
	command(char *)		- execute a single scripted command
	initialise(char*)	- run the scripts from file
	set_suota_upload(k, a, c, v, file)- server file using set_suota_versioncrypto key k for a/c/v requests
	send_repeat(secs, k, a, c, v) - send a NULL packet with suota data using key k every so many secs (0 to cancel)

The scripted commands are:

        a: autodump			    - a[+/-]
        A: autodump, raw and promiscuous    - A[+/-]
        c: set rf channel 11-26             - c channel
        m: set mac                          - m a:b:c:d:e:f:g
        K: load key (16 hex bytes)          - K key-num value 
        O: receiver on			
        o: receiver off
        p: ping
        P: set promiscuous (snoops any packet)-P[+/-]
        r: set raw - dumps all received pckets-r[+/-]
        s: send a broadcast packet          - s * cmd count 
        s: send a directed packet           - s a:b:c:d:e:f:g cmd count
        !: send a broadcast crypto packet   - ! key-num * cmd count
        !: send a directed crypto packet    - ! key-num a:b:c:d:e:f:g cmd count
        u: suota update listener            - u arch code_base version file
	U: rpt snd packet every N secs      - U N key arch code_base version


Optional Kernel APIs
====================

These APIs are optional, may not be compiled into every board

LED control: (Playa board)

	void leds_rgb(unsigned char * __xdata);	// 6 bytes RRGGBB
	void leds_off();			// turn the LEDs off (and shut down the power inverter)

Daylight sensor: (Playa board)

	unsigned char daylight();		// true if the daylight sensor detects

Keyboard controller: (Playa board)

	void keys_ok();
	void keys_off();

General:

	void uart_init();	// set up uart 0 for output (only) - 9600 baud
	void putchar(char c);
	void putstr(char __code *cp);
	void puthex(unsigned char v);


Interrupts
==========

There are some non-obvious things that need to be saved when you take an interrupt:

- the extra 25xx dptr registers
	- DPS (set to 0 on entry)
	- DPL1
	- DPH1
- parameters and local variables to routines that the compiler
	has made static (ie all of them) - we provide a 
	queue_task_0() that saves the time parameter to 
	queue_task() for you and passes 0
	
Check out the examples provided

Notes about memory
==================

8051 memory is complex there's lots of different types - SDCC names the:

- __bit - bytes 0x20-0x37 of direct memory as bits
- __data - bytes 0x40-0x7f of direct memory as bytes
- __pdata - bytes  0x0000-0x00ff of sram 
- __xdata - bytes 0x0000-???? of sram

The compiler normally allocates memory (from all of these) and has already allocated some space for
the kernel, short term we're compiling apps and the kernel together, later we'll have a mechanism
so that an app can compile against a kernel's symbol table so that memory doesn't get double allocated 
(and we can call kernel routines).

It's recommended that you type all your pointers with the memory it points to - the untyped pointer
implementation is slow.
